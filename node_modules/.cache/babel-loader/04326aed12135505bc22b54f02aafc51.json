{"ast":null,"code":"(function (TRUE, FALSE, NULL, undefined) {\n  var root = this; // Variablizing the strings for consistency\n  // and to avoid harmful dot-notation look-ups with\n  // javascript keywords\n\n  var sNull = 'Null',\n      sUndefined = 'Undefined',\n      sInfinity = 'Infinity',\n      sDate = 'Date',\n      sNaN = 'NaN',\n      sNumber = 'Number',\n      sString = 'String',\n      sObject = 'Object',\n      sArray = 'Array',\n      sRegExp = 'RegExp',\n      sBoolean = 'Boolean',\n      sFunction = 'Function',\n      sElement = 'Element'; // Utilizing the non-standard (but available in modern browsers) Global Object names\n  // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n  // Provide a polyfill for items without names\n\n  (function () {\n    var globalObjects = [sDate, sNumber, sString, sObject, sArray, sRegExp, sBoolean, sFunction, sElement],\n        idx = globalObjects.length,\n        globalObject;\n\n    while (idx--) {\n      globalObject = globalObjects[idx];\n\n      if (root[globalObject] !== undefined) {\n        if (!root[globalObject].name) {\n          root[globalObject].name = globalObject;\n        }\n      }\n    }\n  })();\n  /**\n   * Possible values\n   * @type {Object}\n   */\n\n\n  var _types = {};\n  _types[sNull] = 0;\n  _types[sUndefined] = 1;\n  _types[sInfinity] = 2;\n  _types[sDate] = 3;\n  _types[sNaN] = 4;\n  _types[sNumber] = 5;\n  _types[sString] = 6;\n  _types[sObject] = 7;\n  _types[sArray] = 8;\n  _types[sRegExp] = 9;\n  _types[sBoolean] = 10;\n  _types[sFunction] = 11;\n  _types[sElement] = 12;\n  /**\n   * Cached reference to Object.prototype.toString\n   * for type checking\n   * @type {Function}\n   */\n\n  var _toString = function (toString) {\n    return function (obj) {\n      return toString.call(obj);\n    };\n  }({}.toString),\n      _noopArr = [],\n\n  /**\n   * Type checks\n   */\n  _checkMap = function (map) {\n    var types = [// Only mapping items that need to be mapped.\n    // Items not in this list are doing faster\n    // (non-string) checks\n    //\n    // 0 = key, 1 = value\n    [sDate, _types[sDate]], [sNumber, _types[sNumber]], [sString, _types[sString]], [sObject, _types[sObject]], [sArray, _types[sArray]], [sRegExp, _types[sRegExp]], [sFunction, _types[sFunction]]],\n        idx = types.length;\n\n    while (idx--) {\n      map['[object ' + types[idx][0] + ']'] = types[idx][1];\n    }\n\n    return map;\n  }({}),\n\n  /**\n   * Mini extend\n   * @param  {Function} base\n   * @param  {Object}   obj\n   * @return {Function} base\n   */\n  extend = function (base, obj) {\n    var key;\n\n    for (key in obj) {\n      base[key] = obj[key];\n    }\n\n    return base;\n  };\n\n  var callLengths = {\n    0: function (fn, args, context) {\n      if (!context) {\n        return fn();\n      }\n\n      return fn.call(context);\n    },\n    1: function (fn, args, context) {\n      return fn.call(context, args[0]);\n    },\n    2: function (fn, args, context) {\n      return fn.call(context, args[0], args[1]);\n    },\n    3: function (fn, args, context) {\n      return fn.call(context, args[0], args[1], args[2]);\n    }\n  };\n\n  var caller = function (fn, args, context) {\n    var call = callLengths[args.length];\n\n    if (call) {\n      return call(fn, args, context);\n    }\n\n    return fn.apply(context, args);\n  };\n\n  var _getConfigurationType = function (val) {\n    if (val === null) {\n      return _types[sNull];\n    }\n\n    if (val === undefined) {\n      return _types[sUndefined];\n    } // we have something, but don't know what\n\n\n    if (!val.name) {\n      if (val === root[sElement]) {\n        return _types[sElement];\n      } // Firefox doesn't allow setting the name of Element\n\n\n      if (val !== +val) {\n        return _types[sNaN];\n      } // NaN check\n\n\n      return _types[sInfinity]; // Infinity check\n    }\n\n    return _types[val.name];\n  };\n\n  var _getParameterType = function (val) {\n    if (val === null) {\n      return _types[sNull];\n    }\n\n    if (val === undefined) {\n      return _types[sUndefined];\n    }\n\n    if (val === TRUE || val === FALSE) {\n      return _types[sBoolean];\n    }\n\n    if (val && val.nodeType === 1) {\n      return _types[sElement];\n    } // Element check from Underscore\n\n\n    var typeString = _toString(val);\n\n    if (_checkMap[typeString] === _types[sNumber]) {\n      if (val !== +val) {\n        return _types[sNaN];\n      } // NaN check\n\n\n      if (!isFinite(val)) {\n        return _types[sInfinity];\n      } // Finite check\n\n\n      return _types[sNumber]; // definitely a number\n    }\n\n    return _checkMap[typeString];\n  };\n\n  var _convertConfigurationTypes = function (args) {\n    var parameters = [],\n        idx = 0,\n        length = args.length,\n        configItem;\n\n    for (; idx < length; idx++) {\n      configItem = args[idx];\n      parameters.push(configItem instanceof Custom ? configItem : _getConfigurationType(configItem));\n    }\n\n    return parameters;\n  };\n\n  var _convertConfigurationMap = function (map) {\n    var parameters = {},\n        key,\n        configItem;\n\n    for (key in map) {\n      configItem = map[key];\n      parameters[key] = configItem instanceof Custom ? configItem : _getConfigurationType(configItem);\n    }\n\n    return parameters;\n  };\n\n  var _convertParametersTypes = function (args) {\n    var parameters = [],\n        idx = 0,\n        length = args.length;\n\n    for (; idx < length; idx++) {\n      parameters.push(_getParameterType(args[idx]));\n    }\n\n    return parameters;\n  };\n\n  var _doesMapMatchArgsTypes = function (map, argTypes, args) {\n    var mapLength = map.length,\n        argLength = argTypes.length;\n\n    if (mapLength === 0 && argLength === 0) {\n      return TRUE;\n    }\n\n    if (mapLength !== argLength) {\n      return FALSE;\n    }\n\n    var idx = 0,\n        mapItem;\n\n    for (; idx < argLength; idx++) {\n      mapItem = map[idx];\n\n      if (mapItem instanceof Custom) {\n        if (mapItem.check(args[idx])) {\n          continue;\n        }\n\n        return FALSE;\n      }\n\n      if (argTypes[idx] !== mapItem) {\n        return FALSE;\n      }\n    }\n\n    return TRUE;\n  };\n\n  var _getArgumentMatch = function (mappings, args) {\n    if (!mappings) {\n      return;\n    }\n\n    var argTypes = _convertParametersTypes(args),\n        idx = 0,\n        length = mappings.length;\n\n    for (; idx < length; idx++) {\n      if (_doesMapMatchArgsTypes(mappings[idx].params, argTypes, args)) {\n        return mappings[idx];\n      }\n    }\n  };\n\n  var _getLengthMatch = function (mappings, args) {\n    if (!mappings) {\n      return;\n    }\n\n    var argLength = args.length,\n        idx = 0,\n        length = mappings.length;\n\n    for (; idx < length; idx++) {\n      if (mappings[idx].length === argLength) {\n        return mappings[idx];\n      }\n    }\n  };\n\n  var _matchAny = function (args, val) {\n    var type = _getParameterType(val),\n        idx = args.length,\n        mapItem;\n\n    while (idx--) {\n      mapItem = args[idx];\n\n      if (mapItem instanceof Custom) {\n        if (mapItem.check(val)) {\n          return TRUE;\n        }\n\n        continue;\n      }\n\n      if (args[idx] === type) {\n        return TRUE;\n      }\n    }\n\n    return FALSE;\n  };\n\n  var _matchMap = function (config, map) {\n    var key, configItem, mapItem;\n\n    for (key in config) {\n      configItem = config[key];\n      mapItem = map[key];\n\n      if (configItem instanceof Custom) {\n        if (!configItem.check(mapItem)) {\n          return FALSE;\n        }\n\n        continue;\n      }\n\n      if (configItem !== _getParameterType(mapItem)) {\n        return FALSE;\n      }\n    }\n\n    return TRUE;\n  };\n  /**\n   * Custom type that validates a value\n   * @constructor\n   * @param {Function} check\n   */\n\n\n  var Custom = function (check) {\n    this.check = check;\n  };\n\n  var o = {\n    wild: new Custom(function () {\n      return TRUE;\n    }),\n    truthy: new Custom(function (val) {\n      return !!val === TRUE;\n    }),\n    falsy: new Custom(function (val) {\n      return !!val === FALSE;\n    }),\n    any: function () {\n      var args = _convertConfigurationTypes(arguments);\n\n      return new Custom(function (val) {\n        return _matchAny(args, val);\n      });\n    },\n    except: function () {\n      var args = _convertConfigurationTypes(arguments);\n\n      return new Custom(function (val) {\n        return !_matchAny(args, val);\n      });\n    },\n    map: function (map) {\n      var mapConfig = _convertConfigurationMap(map);\n\n      return new Custom(function (map) {\n        return _matchMap(mapConfig, map);\n      });\n    }\n  };\n  var fn = {\n    /**\n     * Methods mapped to argument types\n     * Lazily instanciated\n     * @type {Array} argument mapping\n     */\n    // this._m;\n\n    /**\n     * Methods mapped to argument lengths\n     * Lazily instanciated\n     * @type {Array} length mapping\n     */\n    // this._l;\n\n    /**\n     * A fallback function if none\n     * of the criteria match on a call\n     * @type {Function}\n     */\n    // this._f;\n    map: function (map) {\n      var self = this;\n      return {\n        use: function (method) {\n          var argMappings = self._m || (self._m = []);\n          argMappings.push({\n            params: [o.map(map)],\n            method: method\n          });\n          return self;\n        }\n      };\n    },\n    args: function () {\n      var self = this,\n          args = arguments;\n      return {\n        use: function (method) {\n          var argMappings = self._m || (self._m = []);\n          argMappings.push({\n            params: _convertConfigurationTypes(args),\n            method: method\n          });\n          return self;\n        }\n      };\n    },\n    len: function (num) {\n      var self = this;\n      return {\n        use: function (method) {\n          var lengthMappings = self._l || (self._l = []);\n          lengthMappings.push({\n            length: num === undefined ? method.length : num,\n            method: method\n          });\n          return self;\n        }\n      };\n    },\n    error: function (method) {\n      this._err = method;\n      return this;\n    },\n    fallback: function (method) {\n      this._f = method;\n      return this;\n    },\n    call: function () {\n      // prevent function deoptimation\n      var args = arguments,\n          a = [];\n\n      for (var idx = 1, length = args.length; idx < length; idx++) {\n        a[idx] = args[idx];\n      }\n\n      return this._call(args[0], a);\n    },\n    apply: function (context, args) {\n      var a = args;\n\n      if (args && args.callee) {\n        // passed an arguments object,\n        // not an array.\n        // prevent function deoptimation\n        a = [];\n\n        for (var idx = 0, length = args.length; idx < length; idx++) {\n          a[idx] = args[idx];\n        }\n      }\n\n      return this._call(context, a);\n    },\n    bind: function (context) {\n      var self = this;\n      return function () {\n        // prevent function deoptimation\n        var args = arguments,\n            a = [];\n\n        for (var idx = 0, length = args.length; idx < length; idx++) {\n          a[idx] = args[idx];\n        }\n\n        return self._call(context, a);\n      };\n    },\n    expose: function () {\n      var self = this;\n      return function () {\n        // prevent function deoptimation\n        var args = arguments,\n            a = [];\n\n        for (var idx = 0, length = args.length; idx < length; idx++) {\n          a[idx] = args[idx];\n        }\n\n        return self._call(this, a);\n      };\n    },\n    _call: function (context, args) {\n      if (context === root) {\n        context = null;\n      }\n\n      args = args || _noopArr; // Any argument match, of course, already matches\n      // the length match, so this should be done first\n\n      var argMatch = _getArgumentMatch(this._m, args);\n\n      if (argMatch) {\n        return caller(argMatch.method, args, context);\n      } // Check for a length match\n\n\n      var lengthMatch = _getLengthMatch(this._l, args);\n\n      if (lengthMatch) {\n        return caller(lengthMatch.method, args, context);\n      } // Check for a fallback\n\n\n      if (this._f) {\n        return caller(this._f, args, context);\n      } // Error\n\n\n      return this._err ? this._err(args) : api.err;\n    }\n  };\n  fn.fail = fn.err = fn.error;\n  fn.count = fn.size = fn.len;\n\n  var api = function () {\n    var overload = function overload() {\n      return overload._call(overload, arguments);\n    };\n\n    return extend(overload, fn);\n  };\n\n  api.o = o;\n  api.fn = fn;\n\n  api.err = function () {\n    throw 'overload - exception: No methods matched';\n  };\n\n  api.define = api.defineType = function (name, check) {\n    var custom = new Custom(check);\n    return o[name] = custom;\n  };\n\n  api.defineTypes = function (obj) {\n    var key;\n\n    for (key in obj) {\n      api.define(key, obj[key]);\n    }\n\n    return api;\n  };\n\n  if (typeof define === 'function') {\n    // RequireJS\n    define(function () {\n      return api;\n    });\n  } else if (typeof module !== 'undefined' && module.exports) {\n    // CommonJS\n    module.exports = api;\n  } else {\n    root.overload = api;\n    root.o = o;\n  }\n})(true, false, null);","map":{"version":3,"sources":["/srv/python/artist_react/artist/node_modules/overload-js/overload.js"],"names":["TRUE","FALSE","NULL","undefined","root","sNull","sUndefined","sInfinity","sDate","sNaN","sNumber","sString","sObject","sArray","sRegExp","sBoolean","sFunction","sElement","globalObjects","idx","length","globalObject","name","_types","_toString","toString","obj","call","_noopArr","_checkMap","map","types","extend","base","key","callLengths","fn","args","context","caller","apply","_getConfigurationType","val","_getParameterType","nodeType","typeString","isFinite","_convertConfigurationTypes","parameters","configItem","push","Custom","_convertConfigurationMap","_convertParametersTypes","_doesMapMatchArgsTypes","argTypes","mapLength","argLength","mapItem","check","_getArgumentMatch","mappings","params","_getLengthMatch","_matchAny","type","_matchMap","config","o","wild","truthy","falsy","any","arguments","except","mapConfig","self","use","method","argMappings","_m","len","num","lengthMappings","_l","error","_err","fallback","_f","a","_call","callee","bind","expose","argMatch","lengthMatch","api","err","fail","count","size","overload","define","defineType","custom","defineTypes","module","exports"],"mappings":"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","sourcesContent":["(function(TRUE, FALSE, NULL, undefined) {\n\n\tvar root = this;\n\n\t// Variablizing the strings for consistency\n\t// and to avoid harmful dot-notation look-ups with\n\t// javascript keywords\n\tvar sNull      = 'Null',\n\t\tsUndefined = 'Undefined',\n\t\tsInfinity  = 'Infinity',\n\t\tsDate      = 'Date',\n\t\tsNaN       = 'NaN',\n\t\tsNumber    = 'Number',\n\t\tsString    = 'String',\n\t\tsObject    = 'Object',\n\t\tsArray     = 'Array',\n\t\tsRegExp    = 'RegExp',\n\t\tsBoolean   = 'Boolean',\n\t\tsFunction  = 'Function',\n\t\tsElement   = 'Element';\n\n\t// Utilizing the non-standard (but available in modern browsers) Global Object names\n\t// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\t// Provide a polyfill for items without names\n\t(function() {\n\t\tvar globalObjects = [\n\t\t\t\tsDate,\n\t\t\t\tsNumber,\n\t\t\t\tsString,\n\t\t\t\tsObject,\n\t\t\t\tsArray,\n\t\t\t\tsRegExp,\n\t\t\t\tsBoolean,\n\t\t\t\tsFunction,\n\t\t\t\tsElement\n\t\t\t],\n\t\t\tidx = globalObjects.length,\n\t\t\tglobalObject;\n\t\twhile (idx--) {\n\t\t\tglobalObject = globalObjects[idx];\n\t\t\tif (root[globalObject] !== undefined) {\n\t\t\t\tif (!root[globalObject].name) {\n\t\t\t\t\troot[globalObject].name = globalObject;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}());\n\n\t/**\n\t * Possible values\n\t * @type {Object}\n\t */\n\tvar _types = {};\n\t_types[sNull]      = 0;\n\t_types[sUndefined] = 1;\n\t_types[sInfinity]  = 2;\n\t_types[sDate]      = 3;\n\t_types[sNaN]       = 4;\n\t_types[sNumber]    = 5;\n\t_types[sString]    = 6;\n\t_types[sObject]    = 7;\n\t_types[sArray]     = 8;\n\t_types[sRegExp]    = 9;\n\t_types[sBoolean]   = 10;\n\t_types[sFunction]  = 11;\n\t_types[sElement]   = 12;\n\n\t/**\n\t * Cached reference to Object.prototype.toString\n\t * for type checking\n\t * @type {Function}\n\t */\n\tvar _toString = (function(toString) {\n\t\t\treturn function(obj) {\n\t\t\t\treturn toString.call(obj);\n\t\t\t};\n\t\t}(({}).toString)),\n\n\t\t_noopArr = [],\n\n\t\t/**\n\t\t * Type checks\n\t\t */\n\t\t_checkMap = (function(map) {\n\n\t\t\tvar types = [\n\t\t\t\t\t// Only mapping items that need to be mapped.\n\t\t\t\t\t// Items not in this list are doing faster\n\t\t\t\t\t// (non-string) checks\n\t\t\t\t\t//\n\t\t\t\t\t// 0 = key, 1 = value\n\t\t\t\t\t[ sDate,     _types[sDate]     ],\n\t\t\t\t\t[ sNumber,   _types[sNumber]   ],\n\t\t\t\t\t[ sString,   _types[sString]   ],\n\t\t\t\t\t[ sObject,   _types[sObject]   ],\n\t\t\t\t\t[ sArray,    _types[sArray]    ],\n\t\t\t\t\t[ sRegExp,   _types[sRegExp]   ],\n\t\t\t\t\t[ sFunction, _types[sFunction] ]\n\t\t\t\t],\n\t\t\t\tidx = types.length;\n\t\t\twhile (idx--) {\n\t\t\t\tmap['[object ' + types[idx][0] + ']'] = types[idx][1];\n\t\t\t}\n\n\t\t\treturn map;\n\n\t\t}({})),\n\n\t\t/**\n\t\t * Mini extend\n\t\t * @param  {Function} base\n\t\t * @param  {Object}   obj\n\t\t * @return {Function} base\n\t\t */\n\t\textend = function(base, obj) {\n\t\t\tvar key;\n\t\t\tfor (key in obj) {\n\t\t\t\tbase[key] = obj[key];\n\t\t\t}\n\t\t\treturn base;\n\t\t};\n\n\tvar callLengths = {\n\t\t0: function(fn, args, context) {\n\t\t\tif (!context) { return fn(); }\n\t\t\treturn fn.call(context);\n\t\t},\n\t\t1: function(fn, args, context) {\n\t\t\treturn fn.call(context, args[0]);\n\t\t},\n\t\t2: function(fn, args, context) {\n\t\t\treturn fn.call(context, args[0], args[1]);\n\t\t},\n\t\t3: function(fn, args, context) {\n\t\t\treturn fn.call(context, args[0], args[1], args[2]);\n\t\t}\n\t};\n\tvar caller = function(fn, args, context) {\n\t\tvar call = callLengths[args.length];\n\t\tif (call) { return call(fn, args, context); }\n\t\treturn fn.apply(context, args);\n\t};\n\n\tvar _getConfigurationType = function(val) {\n\t\tif (val === null) { return _types[sNull]; }\n\t\tif (val === undefined) { return _types[sUndefined]; }\n\n\t\t// we have something, but don't know what\n\t\tif (!val.name) {\n\t\t\tif (val === root[sElement]) { return _types[sElement]; } // Firefox doesn't allow setting the name of Element\n\t\t\tif (val !== +val) { return _types[sNaN]; } // NaN check\n\t\t\treturn _types[sInfinity]; // Infinity check\n\t\t}\n\n\t\treturn _types[val.name];\n\t};\n\n\tvar _getParameterType = function(val) {\n\t\tif (val === null) { return _types[sNull]; }\n\t\tif (val === undefined) { return _types[sUndefined]; }\n\t\tif (val === TRUE || val === FALSE) { return _types[sBoolean]; }\n\t\tif (val && val.nodeType === 1) { return _types[sElement]; } // Element check from Underscore\n\n\t\tvar typeString = _toString(val);\n\t\tif (_checkMap[typeString] === _types[sNumber]) {\n\t\t\tif (val !== +val) { return _types[sNaN]; } // NaN check\n\t\t\tif (!isFinite(val)) { return _types[sInfinity]; } // Finite check\n\t\t\treturn _types[sNumber]; // definitely a number\n\t\t}\n\n\t\treturn _checkMap[typeString];\n\t};\n\n\tvar _convertConfigurationTypes = function(args) {\n\t\tvar parameters = [],\n\t\t\tidx = 0, length = args.length,\n\t\t\tconfigItem;\n\t\tfor (; idx < length; idx++) {\n\t\t\tconfigItem = args[idx];\n\t\t\tparameters.push(\n\t\t\t\t(configItem instanceof Custom) ? configItem : _getConfigurationType(configItem)\n\t\t\t);\n\t\t}\n\t\treturn parameters;\n\t};\n\n\tvar _convertConfigurationMap = function(map) {\n\t\tvar parameters = {},\n\t\t\tkey, configItem;\n\t\tfor (key in map) {\n\t\t\tconfigItem = map[key];\n\t\t\tparameters[key] = (configItem instanceof Custom) ? configItem : _getConfigurationType(configItem);\n\t\t}\n\t\treturn parameters;\n\t};\n\n\tvar _convertParametersTypes = function(args) {\n\t\tvar parameters = [],\n\t\t\tidx = 0, length = args.length;\n\t\tfor (; idx < length; idx++) {\n\t\t\tparameters.push(_getParameterType(args[idx]));\n\t\t}\n\t\treturn parameters;\n\t};\n\n\tvar _doesMapMatchArgsTypes = function(map, argTypes, args) {\n\t\tvar mapLength = map.length,\n\t\t\targLength = argTypes.length;\n\n\t\tif (mapLength === 0 && argLength === 0) { return TRUE; }\n\t\tif (mapLength !== argLength) { return FALSE; }\n\n\t\tvar idx = 0,\n\t\t\tmapItem;\n\t\tfor (; idx < argLength; idx++) {\n\t\t\tmapItem = map[idx];\n\n\t\t\tif (mapItem instanceof Custom) {\n\t\t\t\tif (mapItem.check(args[idx])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (argTypes[idx] !== mapItem) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\treturn TRUE;\n\t};\n\n\tvar _getArgumentMatch = function(mappings, args) {\n\t\tif (!mappings) { return; }\n\n\t\tvar argTypes = _convertParametersTypes(args),\n\t\t\tidx = 0, length = mappings.length;\n\t\tfor (; idx < length; idx++) {\n\t\t\tif (_doesMapMatchArgsTypes(mappings[idx].params, argTypes, args)) {\n\t\t\t\treturn mappings[idx];\n\t\t\t}\n\t\t}\n\t};\n\n\tvar _getLengthMatch = function(mappings, args) {\n\t\tif (!mappings) { return; }\n\n\t\tvar argLength = args.length,\n\t\t\tidx = 0, length = mappings.length;\n\t\tfor (; idx < length; idx++) {\n\t\t\tif (mappings[idx].length === argLength) {\n\t\t\t\treturn mappings[idx];\n\t\t\t}\n\t\t}\n\t};\n\n\tvar _matchAny = function(args, val) {\n\t\tvar type = _getParameterType(val),\n\t\t\tidx = args.length,\n\t\t\tmapItem;\n\n\t\twhile (idx--) {\n\t\t\tmapItem = args[idx];\n\n\t\t\tif (mapItem instanceof Custom) {\n\t\t\t\tif (mapItem.check(val)) {\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (args[idx] === type) {\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\n\t\treturn FALSE;\n\t};\n\n\tvar _matchMap = function(config, map) {\n\t\tvar key, configItem, mapItem;\n\t\tfor (key in config) {\n\t\t\tconfigItem = config[key];\n\t\t\tmapItem = map[key];\n\n\t\t\tif (configItem instanceof Custom) {\n\t\t\t\tif (!configItem.check(mapItem)) {\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (configItem !== _getParameterType(mapItem)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\treturn TRUE;\n\t};\n\n\t/**\n\t * Custom type that validates a value\n\t * @constructor\n\t * @param {Function} check\n\t */\n\tvar Custom = function(check) {\n\t\tthis.check = check;\n\t};\n\n\tvar o = {\n\t\twild: new Custom(function() {\n\t\t\treturn TRUE;\n\t\t}),\n\t\ttruthy: new Custom(function(val) {\n\t\t\treturn !!val === TRUE;\n\t\t}),\n\t\tfalsy: new Custom(function(val) {\n\t\t\treturn !!val === FALSE;\n\t\t}),\n\t\tany: function() {\n\t\t\tvar args = _convertConfigurationTypes(arguments);\n\t\t\treturn new Custom(function(val) {\n\t\t\t\treturn _matchAny(args, val);\n\t\t\t});\n\t\t},\n\t\texcept: function() {\n\t\t\tvar args = _convertConfigurationTypes(arguments);\n\t\t\treturn new Custom(function(val) {\n\t\t\t\treturn !_matchAny(args, val);\n\t\t\t});\n\t\t},\n\t\tmap: function(map) {\n\t\t\tvar mapConfig = _convertConfigurationMap(map);\n\t\t\treturn new Custom(function(map) {\n\t\t\t\treturn _matchMap(mapConfig, map);\n\t\t\t});\t\n\t\t}\n\t};\n\n\tvar fn = {\n\t\t/**\n\t\t * Methods mapped to argument types\n\t\t * Lazily instanciated\n\t\t * @type {Array} argument mapping\n\t\t */\n\t\t// this._m;\n\n\t\t/**\n\t\t * Methods mapped to argument lengths\n\t\t * Lazily instanciated\n\t\t * @type {Array} length mapping\n\t\t */\n\t\t// this._l;\n\n\t\t/**\n\t\t * A fallback function if none\n\t\t * of the criteria match on a call\n\t\t * @type {Function}\n\t\t */\n\t\t// this._f;\n\n\t\tmap: function(map) {\n\t\t\tvar self = this;\n\n\t\t\treturn {\n\t\t\t\tuse: function(method) {\n\t\t\t\t\tvar argMappings = self._m || (self._m = []);\n\t\t\t\t\targMappings.push({\n\t\t\t\t\t\tparams: [o.map(map)],\n\t\t\t\t\t\tmethod: method\n\t\t\t\t\t});\n\t\t\t\t\treturn self;\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\targs: function() {\n\t\t\tvar self = this,\n\t\t\t\targs = arguments;\n\n\t\t\treturn {\n\t\t\t\tuse: function(method) {\n\t\t\t\t\tvar argMappings = self._m || (self._m = []);\n\t\t\t\t\targMappings.push({\n\t\t\t\t\t\tparams: _convertConfigurationTypes(args),\n\t\t\t\t\t\tmethod: method\n\t\t\t\t\t});\n\t\t\t\t\treturn self;\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\tlen: function(num) {\n\t\t\tvar self = this;\n\t\t\treturn {\n\t\t\t\tuse: function(method) {\n\t\t\t\t\tvar lengthMappings = self._l || (self._l = []);\n\t\t\t\t\tlengthMappings.push({\n\t\t\t\t\t\tlength: (num === undefined) ? method.length : num,\n\t\t\t\t\t\tmethod: method\n\t\t\t\t\t});\n\t\t\t\t\treturn self;\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\terror: function(method) {\n\t\t\tthis._err = method;\n\t\t\treturn this;\n\t\t},\n\n\t\tfallback: function(method) {\n\t\t\tthis._f = method;\n\t\t\treturn this;\n\t\t},\n\n\t\tcall: function() {\n\t\t\t// prevent function deoptimation\n\t\t\tvar args = arguments, a = [];\n\t\t\tfor (var idx = 1, length = args.length; idx < length; idx++) {\n\t\t\t\ta[idx] = args[idx];\n\t\t\t}\n\t\t\treturn this._call(args[0], a);\n\t\t},\n\n\t\tapply: function(context, args) {\n\t\t\tvar a = args;\n\t\t\tif (args && args.callee)  {\n\t\t\t\t// passed an arguments object,\n\t\t\t\t// not an array.\n\t\t\t\t// prevent function deoptimation\n\t\t\t\ta = [];\n\t\t\t\tfor (var idx = 0, length = args.length; idx < length; idx++) {\n\t\t\t\t\ta[idx] = args[idx];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this._call(context, a);\n\t\t},\n\n\t\tbind: function(context) {\n\t\t\tvar self = this;\n\t\t\treturn function() {\n\t\t\t\t// prevent function deoptimation\n\t\t\t\tvar args = arguments, a = [];\n\t\t\t\tfor (var idx = 0, length = args.length; idx < length; idx++) {\n\t\t\t\t\ta[idx] = args[idx];\n\t\t\t\t}\n\t\t\t\treturn self._call(context, a);\n\t\t\t};\n\t\t},\n\n\t\texpose: function() {\n\t\t\tvar self = this;\n\t\t\treturn function() {\n\t\t\t\t// prevent function deoptimation\n\t\t\t\tvar args = arguments, a = [];\n\t\t\t\tfor (var idx = 0, length = args.length; idx < length; idx++) {\n\t\t\t\t\ta[idx] = args[idx];\n\t\t\t\t}\n\n\t\t\t\treturn self._call(this, a);\n\t\t\t};\n\t\t},\n\n\t\t_call: function(context, args) {\n\t\t\tif (context === root) { context = null; }\n\n\t\t\targs = args || _noopArr;\n\n\t\t\t// Any argument match, of course, already matches\n\t\t\t// the length match, so this should be done first\n\t\t\tvar argMatch = _getArgumentMatch(this._m, args);\n\t\t\tif (argMatch) {\n\t\t\t\treturn caller(argMatch.method, args, context);\n\t\t\t}\n\n\t\t\t// Check for a length match\n\t\t\tvar lengthMatch = _getLengthMatch(this._l, args);\n\t\t\tif (lengthMatch) {\n\t\t\t\treturn caller(lengthMatch.method, args, context);\n\t\t\t}\n\n\t\t\t// Check for a fallback\n\t\t\tif (this._f) {\n\t\t\t\treturn caller(this._f, args, context);\n\t\t\t}\n\n\t\t\t// Error\n\t\t\treturn this._err ? this._err(args) : api.err;\n\t\t}\n\t};\n\n\tfn.fail = fn.err = fn.error;\n\tfn.count = fn.size = fn.len;\n\n\tvar api = function() {\n\t\tvar overload = function overload() {\n\t\t\treturn overload._call(overload, arguments);\n\t\t};\n\t\treturn extend(overload, fn);\n\t};\n\tapi.o = o;\n\tapi.fn = fn;\n\tapi.err = function() {\n\t\tthrow 'overload - exception: No methods matched';\n\t};\n\tapi.define = api.defineType = function(name, check) {\n\t\tvar custom = new Custom(check);\n\t\treturn (o[name] = custom);\n\t};\n\tapi.defineTypes = function(obj) {\n\t\tvar key;\n\t\tfor (key in obj) {\n\t\t\tapi.define(key, obj[key]);\n\t\t}\n\t\treturn api;\n\t};\n\n\tif (typeof define === 'function') { // RequireJS\n        define(function() { return api; });\n    }  else if (typeof module !== 'undefined' && module.exports) { // CommonJS\n        module.exports = api;\n    } else {\n\t\troot.overload = api;\n\t\troot.o = o;\n    }\n\n}(true, false, null));\n"]},"metadata":{},"sourceType":"script"}